<!DOCTYPE html>
<html>
<head lang="en">
  <meta charset="UTF-8">
  <title>旋转木马轮播图</title>
  <link rel="stylesheet" href="css/css.css"/>
</head>
<body>
<div class="wrap" id="wrap">
  <div class="slide" id="slide">
    <ul>
      <li><a href="#"><img src="images/slidepic1.jpg" alt=""/></a></li>
      <li><a href="#"><img src="images/slidepic2.jpg" alt=""/></a></li>
      <li><a href="#"><img src="images/slidepic3.jpg" alt=""/></a></li>
      <li><a href="#"><img src="images/slidepic4.jpg" alt=""/></a></li>
      <li><a href="#"><img src="images/slidepic5.jpg" alt=""/></a></li>
    </ul>
    <div class="arrow" id="arrow">
      <a href="javascript:;" class="prev" id="arrLeft"></a>
      <a href="javascript:;" class="next" id="arrRight"></a>
    </div>
  </div>
</div>
<script>
  //标注了每个图片要运动到的位置
  var config = [
    {
      width: 400,
      top: 20,
      left: 50,
      opacity: 0.2,
      zIndex: 2
    },//0
    {
      width: 600,
      top: 70,
      left: 0,
      opacity: 0.8,
      zIndex: 3
    },//1
    {
      width: 800,
      top: 100,
      left: 200,
      opacity: 1,
      zIndex: 4
    },//2
    {
      width: 600,
      top: 70,
      left: 600,
      opacity: 0.8,
      zIndex: 3
    },//3
    {
      width: 400,
      top: 20,
      left: 750,
      opacity: 0.2,
      zIndex: 2
    },//4
  ];//config其实就是一个配置单 规定了每张图片的大小位置层级透明度
  
  //步骤:
  //1 让每一个li，根据config中的对象运动到执行的位置
  //2 鼠标移入移出，设置箭头的渐入和渐出(透明度的修改)
  //3 点击左右后，实际上修改的是config数组中的对象的顺序，li所对应的位置所致改变
  
  
  //实现：
  //1 获取元素
  var wrap = document.getElementById("wrap");//大盒子
  var slide = wrap.children[0];
  var ul = slide.children[0];//ul
  var lis = ul.children;//要运动的每个li
  var arrBox = slide.children[1];//箭头父盒子
  var arrLeft = arrBox.children[0];
  var arrRight = arrBox.children[1];
  
  //2 让lis中的每个li，根据config中的对应对象进行初始位置设置
  for (var i = 0; i < config.length; i++) {
    animate(lis[i], config[i]);
  }
  //3 设置移入移出操作
  slide.onmouseover = function () {
    animate(arrBox, {opacity: 1});
  };
  slide.onmouseout = function () {
    animate(arrBox, {opacity: 0});
  };
  var flag = true;//控制点击事件内的代码是否可以执行
  //4 右键头操作
  arrRight.onclick = function () {
    if (flag) {
      //将config中第一个元素移动到最后
      config.push(config.shift());
      //设置li根据config中的新位置进行运动
      changePos();
      
      flag = false;
    }
  };
  //5 左箭头操作
  arrLeft.onclick = function () {
    if (flag) {
      //将config中最后一个元素移动到最前面
      config.unshift(config.pop());
      //设置li根据config中的新位置进行运动
      changePos();
      
      flag = false;
    }
  };
  
  var count = 0;//用于记录当前运动完毕的li的个数
  //如果运动完毕的li有5个，设置flag为true同时设置count清零即可
  function changePos() {
    for (var i = 0; i < config.length; i++) {
      animate(lis[i], config[i], function () {
        /*//设置flag的值为true
         flag = true;*/
        
        //严谨的方式：
        count++;//设置计数增加
        
        //检测count的值是否到达目标值
        if (count == lis.length) {
          flag = true;
          count = 0;
        }
      });
    }
  }
  
  
  function animate(tag, obj, fn) {
    clearInterval(tag.timer);//防止加速
    tag.timer = setInterval(function () {
      var flag = true;
      
      for (var k in obj) {
        //k的值可能为opacity或者zIndex，如果是这些值，在设置时需要进行单独设置
        if (k == "opacity") {
          var styleName = k;
          //由于后面需要对current和target的大小进行检测，所以需要进行对应的倍数扩大
          var target = obj[k] * 100;
          
          //opacity是0-1之间的值,不能取整。而且发现ie中也不会出现auto，后面的||0也可以去掉了
          var current = getStyle(tag, styleName) * 100;
          var step = (target - current) / 10;
          step = step > 0 ? Math.ceil(step) : Math.floor(step);
          current = current + step;
          //设置时除以扩大的倍数，去除px单位
          tag.style[styleName] = current / 100;
          
          if (current != target) {
            flag = false;
          }
        } else if (k == "zIndex") {
          //  层级不需要设置运动，直接设置为对应的值即可
          tag.style.zIndex = obj.zIndex;
        } else {
          var styleName = k;
          var target = obj[k];
          
          //可以让某个样式运动到指定的值
          var current = parseInt(getStyle(tag, styleName)) || 0;
          var step = (target - current) / 10;
          step = step > 0 ? Math.ceil(step) : Math.floor(step);
          current = current + step;
          //需要修改的位置2：设置样式
          tag.style[styleName] = current + "px";
          
          
          if (current != target) {
            flag = false;
          }
        }
      }
      
      if (flag) {
        clearInterval(tag.timer);
        fn && fn();
      }
      
    }, 20);
  }
  
  
  function getStyle(tag, styleName) {
    if (tag.currentStyle) {
      return tag.currentStyle[styleName];
    } else {
      return getComputedStyle(tag)[styleName];
    }
  }
</script>
</body>
</html>
